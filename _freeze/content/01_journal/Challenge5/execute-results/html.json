{
  "hash": "cf0d70487a4c3404ba5563b5fd5ea2f0",
  "result": {
    "markdown": "---\ntitle: \"Challenge 5\"\nauthor: \"Dominik Haller\"\n---\n\nFor the leaderboard visualization and the cow plot see challenge 4.\n\n::: {.cell hash='Challenge5_cache/html/unnamed-chunk-1_ced78982a49205372ad1e866d0c22061'}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n#> ✔ dplyr     1.1.2     ✔ readr     2.1.4\n#> ✔ forcats   1.0.0     ✔ stringr   1.5.0\n#> ✔ ggplot2   3.4.2     ✔ tibble    3.2.1\n#> ✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n#> ✔ purrr     1.0.1     \n#> ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n#> ✖ dplyr::filter() masks stats::filter()\n#> ✖ dplyr::lag()    masks stats::lag()\n#> ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(h2o)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> \n#> ----------------------------------------------------------------------\n#> \n#> Your next step is to start H2O:\n#>     > h2o.init()\n#> \n#> For H2O package documentation, ask for help:\n#>     > ??h2o\n#> \n#> After starting H2O, you can use the Web UI at http://localhost:54321\n#> For more information visit https://docs.h2o.ai\n#> \n#> ----------------------------------------------------------------------\n#> \n#> \n#> Attache Paket: 'h2o'\n#> \n#> Die folgenden Objekte sind maskiert von 'package:lubridate':\n#> \n#>     day, hour, month, week, year\n#> \n#> Die folgenden Objekte sind maskiert von 'package:stats':\n#> \n#>     cor, sd, var\n#> \n#> Die folgenden Objekte sind maskiert von 'package:base':\n#> \n#>     %*%, %in%, &&, ||, apply, as.factor, as.numeric, colnames,\n#>     colnames<-, ifelse, is.character, is.factor, is.numeric, log,\n#>     log10, log1p, log2, round, signif, trunc\n```\n:::\n\n```{.r .cell-code}\nlibrary(rsample)\nlibrary(recipes)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> \n#> Attache Paket: 'recipes'\n#> \n#> Das folgende Objekt ist maskiert 'package:stringr':\n#> \n#>     fixed\n#> \n#> Das folgende Objekt ist maskiert 'package:stats':\n#> \n#>     step\n```\n:::\n\n```{.r .cell-code}\n# Load Data\nproduct_backorders <- read_csv(\"product_backorders.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Rows: 19053 Columns: 23\n#> ── Column specification ────────────────────────────────────────────────────────\n#> Delimiter: \",\"\n#> chr  (7): potential_issue, deck_risk, oe_constraint, ppap_risk, stop_auto_bu...\n#> dbl (16): sku, national_inv, lead_time, in_transit_qty, forecast_3_month, fo...\n#> \n#> ℹ Use `spec()` to retrieve the full column specification for this data.\n#> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n```{.r .cell-code}\n# Split Data\nset.seed(123)\nsplit_obj <- initial_split(product_backorders, prop = 0.85)\ntrain_readable_tbl <- training(split_obj)\ntest_readable_tbl <- testing(split_obj)\n\nproduct_rec <- recipe(went_on_backorder ~ ., data = train_readable_tbl) %>% \n  step_dummy(all_nominal(), -all_outcomes()) %>% \n  step_zv(all_predictors()) %>% \n  prep()\n\ntrain_data <- bake(product_rec, new_data = train_readable_tbl)\ntest_data <- bake(product_rec, new_data = test_readable_tbl)\n\nh2o.init()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n#> H2O is not running yet, starting it now...\n#> \n#> Note:  In case of errors look at the following log files:\n#>     C:\\Users\\Domin\\AppData\\Local\\Temp\\RtmpaWzYvg\\file10c459f610f6/h2o_Domin_started_from_r.out\n#>     C:\\Users\\Domin\\AppData\\Local\\Temp\\RtmpaWzYvg\\file10c4286369ab/h2o_Domin_started_from_r.err\n#> \n#> \n#> Starting H2O JVM and connecting:  Connection successful!\n#> \n#> R is connected to the H2O cluster: \n#>     H2O cluster uptime:         3 seconds 471 milliseconds \n#>     H2O cluster timezone:       Europe/Berlin \n#>     H2O data parsing timezone:  UTC \n#>     H2O cluster version:        3.40.0.1 \n#>     H2O cluster version age:    3 months and 7 days \n#>     H2O cluster name:           H2O_started_from_R_Domin_adl455 \n#>     H2O cluster total nodes:    1 \n#>     H2O cluster total memory:   3.41 GB \n#>     H2O cluster total cores:    8 \n#>     H2O cluster allowed cores:  8 \n#>     H2O cluster healthy:        TRUE \n#>     H2O Connection ip:          localhost \n#>     H2O Connection port:        54321 \n#>     H2O Connection proxy:       NA \n#>     H2O Internal Security:      FALSE \n#>     R Version:                  R version 4.2.3 (2023-03-15 ucrt)\n```\n:::\n\n```{.r .cell-code}\nsplit_h2o <- h2o.splitFrame(as.h2o(train_data), ratios = c(0.85), seed = 1234)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\ntrain_h2o <- split_h2o[[1]]\nvalid_h2o <- split_h2o[[2]]\ntest_h2o  <- as.h2o(test_data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\ny <- \"went_on_backorder\"\nx <- setdiff(names(train_h2o), y)\n\n#Load Models\nmodel1 <- h2o.loadModel(\"./models/StackedEnsemble_AllModels_1_AutoML_5_20230515_170512\")\nmodel2 <- h2o.loadModel(\"./models/StackedEnsemble_AllModels_2_AutoML_5_20230515_170512\")\nmodel3 <- h2o.loadModel(\"./models/StackedEnsemble_BestOfFamily_3_AutoML_5_20230515_170512\")\n\n\n#Grid Search\nh2o.performance(model1, newdata = as.h2o(test_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n#> H2OBinomialMetrics: stackedensemble\n#> \n#> MSE:  0.05024247\n#> RMSE:  0.2241483\n#> LogLoss:  0.1670338\n#> Mean Per-Class Error:  0.14733\n#> AUC:  0.9487011\n#> AUCPR:  0.7256739\n#> Gini:  0.8974021\n#> \n#> Confusion Matrix (vertical: actual; across: predicted) for F1-optimal threshold:\n#>          No Yes    Error       Rate\n#> No     2389 159 0.062402  =159/2548\n#> Yes      72 238 0.232258    =72/310\n#> Totals 2461 397 0.080826  =231/2858\n#> \n#> Maximum Metrics: Maximum metrics at their respective thresholds\n#>                         metric threshold       value idx\n#> 1                       max f1  0.275779    0.673267 204\n#> 2                       max f2  0.112598    0.759320 276\n#> 3                 max f0point5  0.682088    0.719770  83\n#> 4                 max accuracy  0.682088    0.932470  83\n#> 5                max precision  0.984244    1.000000   0\n#> 6                   max recall  0.006402    1.000000 381\n#> 7              max specificity  0.984244    1.000000   0\n#> 8             max absolute_mcc  0.275779    0.634203 204\n#> 9   max min_per_class_accuracy  0.122757    0.883871 271\n#> 10 max mean_per_class_accuracy  0.085867    0.888402 291\n#> 11                     max tns  0.984244 2548.000000   0\n#> 12                     max fns  0.984244  309.000000   0\n#> 13                     max fps  0.000110 2548.000000 399\n#> 14                     max tps  0.006402  310.000000 381\n#> 15                     max tnr  0.984244    1.000000   0\n#> 16                     max fnr  0.984244    0.996774   0\n#> 17                     max fpr  0.000110    1.000000 399\n#> 18                     max tpr  0.006402    1.000000 381\n#> \n#> Gains/Lift Table: Extract with `h2o.gainsLift(<model>, <data>)` or `h2o.gainsLift(<model>, valid=<T/F>, xval=<T/F>)`\n```\n:::\n\n```{.r .cell-code}\ndeeplearning_grid_01 <- h2o.grid(\n  algorithm = \"deeplearning\",\n  grid_id = \"deeplearning_grid_01\",\n  x = x,\n  y = y,\n  training_frame   = train_h2o,\n  validation_frame = valid_h2o,\n  nfolds = 5,\n  hyper_params = list(\n    hidden = list(c(10, 10, 10), c(50, 20, 10), c(20, 20, 20)),\n    epochs = c(10, 50, 100)\n  )\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\ndeeplearning_grid_01_model_1 <- h2o.getModel(\"deeplearning_grid_01_model_1\")\ndeeplearning_grid_01_model_1 %>% h2o.auc(train = T, valid = T, xval = T)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#>     train     valid      xval \n#> 0.7946087 0.8181086 0.7716700\n```\n:::\n\n```{.r .cell-code}\ndeeplearning_grid_01_model_1 %>%\n  h2o.performance(newdata = as.h2o(test_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n#> H2OBinomialMetrics: deeplearning\n#> \n#> MSE:  0.08439949\n#> RMSE:  0.2905159\n#> LogLoss:  0.2888497\n#> Mean Per-Class Error:  0.3310098\n#> AUC:  0.7899535\n#> AUCPR:  0.3611289\n#> Gini:  0.5799071\n#> \n#> Confusion Matrix (vertical: actual; across: predicted) for F1-optimal threshold:\n#>          No Yes    Error       Rate\n#> No     2316 232 0.091052  =232/2548\n#> Yes     177 133 0.570968   =177/310\n#> Totals 2493 365 0.143107  =409/2858\n#> \n#> Maximum Metrics: Maximum metrics at their respective thresholds\n#>                         metric threshold       value idx\n#> 1                       max f1  0.161665    0.394074 155\n#> 2                       max f2  0.127742    0.506053 208\n#> 3                 max f0point5  0.216930    0.457516 105\n#> 4                 max accuracy  0.218462    0.897481 104\n#> 5                max precision  0.992217    1.000000   0\n#> 6                   max recall  0.016464    1.000000 370\n#> 7              max specificity  0.992217    1.000000   0\n#> 8             max absolute_mcc  0.211135    0.339970 111\n#> 9   max min_per_class_accuracy  0.118667    0.710754 223\n#> 10 max mean_per_class_accuracy  0.127742    0.716218 208\n#> 11                     max tns  0.992217 2548.000000   0\n#> 12                     max fns  0.992217  309.000000   0\n#> 13                     max fps  0.000044 2548.000000 399\n#> 14                     max tps  0.016464  310.000000 370\n#> 15                     max tnr  0.992217    1.000000   0\n#> 16                     max fnr  0.992217    0.996774   0\n#> 17                     max fpr  0.000044    1.000000 399\n#> 18                     max tpr  0.016464    1.000000 370\n#> \n#> Gains/Lift Table: Extract with `h2o.gainsLift(<model>, <data>)` or `h2o.gainsLift(<model>, valid=<T/F>, xval=<T/F>)`\n```\n:::\n\n```{.r .cell-code}\n#Theme\ntheme_new <- theme(\n  legend.position  = \"bottom\",\n  legend.key       = element_blank(),\n  panel.background = element_rect(fill   = \"transparent\"),\n  panel.border     = element_rect(color = \"black\", fill = NA, size = 0.5),\n  panel.grid.major = element_line(color = \"grey\", size = 0.333)\n) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: The `size` argument of `element_rect()` is deprecated as of ggplot2 3.4.0.\n#> ℹ Please use the `linewidth` argument instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: The `size` argument of `element_line()` is deprecated as of ggplot2 3.4.0.\n#> ℹ Please use the `linewidth` argument instead.\n```\n:::\n\n```{.r .cell-code}\n#Optimal Threshold\nperformance_h2o <- h2o.performance(model1, newdata = as.h2o(test_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\nperformance_tbl <- performance_h2o %>%\n  h2o.metric() %>%\n  as_tibble() \n\nperformance_tbl %>%\n  filter(f1 == max(f1))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<div data-pagedtable=\"false\">\n  <script data-pagedtable-source type=\"application/json\">\n{\"columns\":[{\"label\":[\"threshold\"],\"name\":[1],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"f1\"],\"name\":[2],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"f2\"],\"name\":[3],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"f0point5\"],\"name\":[4],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"accuracy\"],\"name\":[5],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"precision\"],\"name\":[6],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"recall\"],\"name\":[7],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"specificity\"],\"name\":[8],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"absolute_mcc\"],\"name\":[9],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"min_per_class_accuracy\"],\"name\":[10],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"mean_per_class_accuracy\"],\"name\":[11],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"tns\"],\"name\":[12],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"fns\"],\"name\":[13],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"fps\"],\"name\":[14],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"tps\"],\"name\":[15],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"tnr\"],\"name\":[16],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"fnr\"],\"name\":[17],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"fpr\"],\"name\":[18],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"tpr\"],\"name\":[19],\"type\":[\"dbl\"],\"align\":[\"right\"]},{\"label\":[\"idx\"],\"name\":[20],\"type\":[\"int\"],\"align\":[\"right\"]}],\"data\":[{\"1\":\"0.2757791\",\"2\":\"0.6732673\",\"3\":\"0.7269395\",\"4\":\"0.6269758\",\"5\":\"0.9191742\",\"6\":\"0.5994962\",\"7\":\"0.7677419\",\"8\":\"0.9375981\",\"9\":\"0.6342026\",\"10\":\"0.7677419\",\"11\":\"0.85267\",\"12\":\"2389\",\"13\":\"72\",\"14\":\"159\",\"15\":\"238\",\"16\":\"0.9375981\",\"17\":\"0.2322581\",\"18\":\"0.06240188\",\"19\":\"0.7677419\",\"20\":\"204\"}],\"options\":{\"columns\":{\"min\":{},\"max\":[10]},\"rows\":{\"min\":[10],\"max\":[10]},\"pages\":{}}}\n  </script>\n</div>\n`````\n:::\n\n```{.r .cell-code}\nperformance_tbl %>%\n  ggplot(aes(x = threshold)) +\n  geom_line(aes(y = precision), color = \"blue\", size = 1) +\n  geom_line(aes(y = recall), color = \"red\", size = 1) +\n  \n  # Insert line where precision and recall are harmonically optimized\n  geom_vline(xintercept = h2o.find_threshold_by_max_metric(performance_h2o, \"f1\")) +\n  labs(title = \"Precision vs Recall\", y = \"value\") +\n  theme_new\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#> ℹ Please use `linewidth` instead.\n```\n:::\n\n::: {.cell-output-display}\n![](Challenge5_files/figure-html/unnamed-chunk-1-1.png){width=672}\n:::\n\n```{.r .cell-code}\n#ROC Plot\npath <- \"models/StackedEnsemble_AllModels_1_AutoML_5_20230515_170512\"\nload_model_performance_metrics <- function(path, test_data) {\n  path\n  model_h2o <- h2o.loadModel(path)\n  perf_h2o  <- h2o.performance(model_h2o, newdata = as.h2o(test_data)) \n  \n  perf_h2o %>%\n    h2o.metric() %>%\n    as_tibble() %>%\n    mutate(auc = h2o.auc(perf_h2o)) %>%\n    select(tpr, fpr, auc, recall, precision)\n  \n}\n\n\nmodel_metrics_tbl <- fs::dir_info(path = \"models/\") %>%\n  select(path) %>%\n  mutate(metrics = map(path, load_model_performance_metrics, test_data)) %>%\n  unnest(cols = metrics)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n#> \n  |                                                                            \n  |                                                                      |   0%\n  |                                                                            \n  |======================================================================| 100%\n```\n:::\n\n```{.r .cell-code}\nmodel_metrics_tbl %>%\n    # Extract the model names\n    mutate(\n      # Extract the model names\n      path = str_split(path, pattern = \"/\", simplify = T)[,2] %>% as_factor(),\n      auc  = auc %>% round(3) %>% as.character() %>% as_factor()\n    ) %>%\n  ggplot(aes(fpr, tpr, color = path, linetype = auc)) +\n  geom_line(size = 1) +\n  \n  # just for demonstration purposes\n  geom_abline(color = \"red\", linetype = \"dotted\") +\n  \n  theme_new +\n  theme(\n    legend.direction = \"vertical\",\n  ) +\n  labs(\n    title = \"ROC Plot\",\n    subtitle = \"Performance of 3 Top Performing Models\"\n  )\n```\n\n::: {.cell-output-display}\n![](Challenge5_files/figure-html/unnamed-chunk-1-2.png){width=672}\n:::\n\n```{.r .cell-code}\n#Precision Vs Recall Plot\nmodel_metrics_tbl %>%\n  mutate(\n    path = str_split(path, pattern = \"/\", simplify = T)[,2] %>% as_factor(),\n    auc  = auc %>% round(3) %>% as.character() %>% as_factor()\n  ) %>%\n  ggplot(aes(recall, precision, color = path, linetype = auc)) +\n  geom_line() +\n  theme_new + \n  theme(\n    legend.direction = \"vertical\",\n  ) +\n  labs(\n    title = \"Precision vs Recall Plot\",\n    subtitle = \"Performance of 3 Top Performing Models\"\n  )\n```\n\n::: {.cell-output-display}\n![](Challenge5_files/figure-html/unnamed-chunk-1-3.png){width=672}\n:::\n\n```{.r .cell-code}\n# Gain Chart\ngain_lift_tbl <- performance_h2o %>%\n  h2o.gainsLift() %>%\n  as.tibble()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n#> Warning: `as.tibble()` was deprecated in tibble 2.0.0.\n#> ℹ Please use `as_tibble()` instead.\n#> ℹ The signature and semantics have changed, see `?as_tibble`.\n```\n:::\n\n```{.r .cell-code}\ngain_transformed_tbl <- gain_lift_tbl %>% \n  select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift) %>%\n  select(-contains(\"lift\")) %>%\n  mutate(baseline = cumulative_data_fraction) %>%\n  rename(gain     = cumulative_capture_rate) %>%\n  # prepare the data for the plotting (for the color and group aesthetics)\n  pivot_longer(cols = c(gain, baseline), values_to = \"value\", names_to = \"key\")\n\ngain_transformed_tbl %>%\n  ggplot(aes(x = cumulative_data_fraction, y = value, color = key)) +\n  geom_line(size = 1.5) +\n  labs(\n    title = \"Gain Chart\",\n    x = \"Cumulative Data Fraction\",\n    y = \"Gain\"\n  ) +\n  theme_new\n```\n\n::: {.cell-output-display}\n![](Challenge5_files/figure-html/unnamed-chunk-1-4.png){width=672}\n:::\n\n```{.r .cell-code}\n## Lift Plot\n\nlift_transformed_tbl <- gain_lift_tbl %>% \n  select(group, cumulative_data_fraction, cumulative_capture_rate, cumulative_lift) %>%\n  select(-contains(\"capture\")) %>%\n  mutate(baseline = 1) %>%\n  rename(lift = cumulative_lift) %>%\n  pivot_longer(cols = c(lift, baseline), values_to = \"value\", names_to = \"key\")\n\nlift_transformed_tbl %>%\n  ggplot(aes(x = cumulative_data_fraction, y = value, color = key)) +\n  geom_line(size = 1.5) +\n  labs(\n    title = \"Lift Chart\",\n    x = \"Cumulative Data Fraction\",\n    y = \"Lift\"\n  ) +\n  theme_new\n```\n\n::: {.cell-output-display}\n![](Challenge5_files/figure-html/unnamed-chunk-1-5.png){width=672}\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../../site_libs/pagedtable-1.1/css/pagedtable.css\" rel=\"stylesheet\" />\r\n<script src=\"../../site_libs/pagedtable-1.1/js/pagedtable.js\"></script>\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}